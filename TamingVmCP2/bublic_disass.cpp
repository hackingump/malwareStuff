#include <iostream>
#include <fstream>
#include <vector>
#include <cstdint>
#include <string>
#include <sstream>
#include "disass.h"
using namespace std;


#define VM_START 0xE000
#define VM_END 0xEBD0
#define CODE_SIZE (VM_END - VM_START)

/**
* Transform int num to hex string
* Return hex string
**/
string to_hex(int num) {
	std::stringstream ss;
	ss << std::hex << num;
	return "0x" + ss.str();
}

/**
* Read vm code from file with filename into char buffer.
* Return true if successful
**/
int read_code(char *filename, char *buf, int offs, int len){
	ifstream file;
	try {
		cout << "[+] Reading from file " << filename << "\n";
		file.open(filename, ios::binary);
		file.seekg(offs);
		file.read(buf, len);
		if(!file){
			cout << "[!] Error reading files!\n";
			return 0;
		}
	} catch(ios_base::failure& e) {
		return 0;
	}
	return 1;
}

/**
* Return 32 bit integer from char buffer.
* Return unsigned int
**/
uint32_t get_dword_from_bytes(char *buf, int pos) {
	return (((int) buf[pos]) & 0x000000FF) | (((int) buf[pos + 1] << 8)& 0x0000FF00) | (((int) buf[pos + 2] << 16) & 0x00FF0000) | (((int) buf[pos + 3]<< 24) & 0xFF000000 );
}

/**
* Return 16 bit integer from char buffer.
* Return unsigned int
**/
uint32_t get_word_from_bytes(char *buf, int pos) {
	return ((int) buf[pos]) | (((int) buf[pos + 1] << 8) & 0x0000FF00);
}

int get_imm(char *buf, int pos, int len){
	if(len > 2)
		return get_dword_from_bytes(buf, pos);
	else if(len == 2)
		return get_word_from_bytes(buf, pos);
	else
		return (int) buf[pos] & 0xFF;

}

// Operand class, representing a single operand
class Operand {
public:
	int opinfo1;
	int opinfo2;
	int optype;
	int oplen;
	char sign;
	int op;
	int rng;

	string get_operand(){
		if(!this->optype){
			if(!this->opinfo1)
				return REGS[op][3];
			else
				return "[" + REGS[op][3] + "]";
		} else if(this->optype == 1){
			return to_hex(this->op);
		} else if(this->optype == 2){
			return "[MEM]";
		}
	};
};

// Instruction class, representing a single instruction
class Instruction {
public:
	int iid;
	int isize;
	int iopcount;
	vector<Operand> ops;

	Instruction(){
		iid = 0;
		isize = 0;
		iopcount = 0;
	};

	Instruction(int p_iid, int p_isize, int p_iopcount){
		iid = p_iid;
		isize = p_isize;
		iopcount = p_iopcount;
	};

	void print_instruction(int vip){
		string instruction = this->get_mnemonic();
		for(int i = 0; i < this->iopcount;i++){
			instruction += " " + ops[i].get_operand();
		}
		cout << hex << vip << "		" << this->iid << "		" << instruction << "\n";
	};

	string get_mnemonic(){
		return INSTRUCTIONS[this->iid];
	}
};

Instruction get_instruction(char *buf, int pos, int isize){
	vector<Operand> ops(2);
	int i = 0;
	int memlen,mathop, memop_cfg, signconfig;
	Instruction inst = Instruction((int) buf[pos], isize, (int) buf[pos + 1] & 3);
	inst.ops = ops;		// Vector with Operands
	if(!inst.iopcount)
		return inst;
	pos += 2;
	// continue loop as long as all operands are parsed
	while(i < inst.iopcount) {
		inst.ops[i].opinfo1 = ((int) buf[pos] >> 4);
		inst.ops[i].opinfo2 = ((int) buf[pos] & 0xF);
		inst.ops[i].optype = ((int) buf[pos + 1]) >> 4;
		inst.ops[i].oplen = ((int) buf[pos + 1] & 0x0F) + 1;
		pos += 2;

		// CASE REGISTER OPERAND
		if(!inst.ops[i].optype){
			if(inst.ops[i].opinfo1 < 3){
				inst.ops[i].op = buf[pos];	
			} else {
				cout << "DECODING ERR\n";
			}
			pos += inst.ops[i].oplen;
		// CASE IMMEDIATE
		} else if(inst.ops[i].optype == 1){
			inst.ops[i].op = get_imm(buf, pos, inst.ops[i].oplen);
			pos += inst.ops[i].oplen;
		// CASE MEMORY OPERAND
		} else if(inst.ops[i].optype == 2){
			do{
				memop_cfg = (int) buf[pos];
				memlen = (memop_cfg >> 4) & 0xFF;
				signconfig = memop_cfg & 8;
				pos += memlen;

			}while(((int)buf[pos]));
			pos++;
		} else{
			break;
		}
		i++;
	}
	return inst;
}

int main(int argc, char *argv[]){
	char *buf;
	int i = 0;
	int iid, isize, iopcount;
	buf = (char *) malloc(0x2000);
	Instruction inst;
	cout << "[+] Disassembling 0x" << hex << CODE_SIZE << " bytes \n";
	if(argc < 2) {
		cout << "No arguments entered, aborting.";
		exit(1);
	}
	if(!read_code(argv[1], buf, VM_START, VM_END - VM_START)){
		cout << "Error reading vm code from file\n";
		exit(0);
	}
	while(i <= (VM_END - VM_START)) {
		iid = (int) buf[i];
		isize = ((int) buf[i + 1]) >> 2;
		iopcount = ((int) buf[i + 1]) & 0x3;
		if(!isize)
			break;
		inst = get_instruction(buf, i, isize);
		inst.print_instruction(i);
		i += isize;
	}
	free(buf);
}
