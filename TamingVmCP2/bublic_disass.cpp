#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#include "disass.h"
using namespace std;

#define VM_START 0xE000
#define VM_END 0xEBD0
#define CODE_SIZE (VM_END - VM_START)

/**
 * Transform int num to hex string
 * Return hex string
 **/
string to_hex(int num) {
  std::stringstream ss;
  ss << std::hex << num;
  return "0x" + ss.str();
}

/**
 * Read vm code from file with filename into char buffer.
 * Return true if successful
 **/
int read_code(char *filename, char *buf, int offs, int len) {
  ifstream fs;
  try {
    cout << "[+] Reading from file " << filename << "\n";
    fs.open(filename, ios::binary);
    fs.seekg(offs);
    fs.read(buf, len);
    if (fs.fail()) {
      cout << "[!] Error reading files!\n";
      return 0;
    }
  } catch (ios_base::failure &e) {
    return 0;
  }
  return 1;
}

/**
 * Return 32 bit integer from char buffer.
 * Return unsigned int
 **/
int32_t get_dword_from_bytes(char *buf, int pos) {
  return (((int)buf[pos]) & 0x000000FF) |
         (((int)buf[pos + 1] << 8) & 0x0000FF00) |
         (((int)buf[pos + 2] << 16) & 0x00FF0000) |
         (((int)buf[pos + 3] << 24) & 0xFF000000);
}

/**
 * Return 16 bit integer from char buffer.
 * Return unsigned int
 **/
int16_t get_word_from_bytes(char *buf, int pos) {
  return ((int)buf[pos]) | (((int)buf[pos + 1] << 8) & 0x0000FF00);
}

int get_imm(char *buf, int pos, int len) {
  if (len > 2)
    return get_dword_from_bytes(buf, pos);
  else if (len == 2)
    return get_word_from_bytes(buf, pos);
  else
    return (int)buf[pos] & 0xFF;
}

// Operand class, representing a single operand
class Operand {
 public:
  int opinfo1;
  int opinfo2;
  int optype;
  int oplen;
  int memoffs;
  int op;
  int reg_mod;

  string get_operand() {
    // Return normal register
    if (!this->optype) {
      if (!this->opinfo1)
        return REGS[op][opinfo2];
      else
        return "[" + REGS[op][3] + "]";
      // Return immediate
    } else if (this->optype == 1) {
      return to_hex(this->op);
      // Return memory access
    } else if (this->optype == 2) {
      string operand = "[" + REGS[op][3];
      if (memoffs < 0)
        operand += std::to_string(memoffs);
      else
        operand += " + " + std::to_string(memoffs);
      // if there is also a register involved, add it too
      if (reg_mod >= 0) operand += " + " + REGS[reg_mod][opinfo2];

      return operand + "]";
    }
  };
};

// Instruction class, representing a single instruction
class Instruction {
 public:
  int iid;
  int isize;
  int iopcount;
  vector<Operand> ops;

  Instruction() {
    iid = 0;
    isize = 0;
    iopcount = 0;
  };

  Instruction(int p_iid, int p_isize, int p_iopcount) {
    iid = p_iid;
    isize = p_isize;
    iopcount = p_iopcount;
  };

  void print_instruction(int vip) {
    string instruction = this->get_mnemonic();
    for (int i = 0; i < this->iopcount; i++) {
      instruction += " " + ops[i].get_operand();
    }
    cout << hex << vip << "		" << this->iid << "		"
         << instruction << "\n";
  };

  string get_mnemonic() { return INSTRUCTIONS[this->iid]; }
};

Instruction get_instruction(char *buf, int pos, int isize) {
  vector<Operand> ops(2);
  int i = 0;
  int memlen, mod, memop_cfg, signconfig;
  int sec_reg = 0;
  Instruction inst = Instruction((int)buf[pos], isize, (int)buf[pos + 1] & 3);
  inst.ops = ops;      // Vector with Operands
  if (!inst.iopcount)  // No operands involved, return it as it is
    return inst;
  pos += 2;
  // continue loop as long as all operands are parsed
  while (i < inst.iopcount) {
    inst.ops[i].opinfo1 = ((int)buf[pos] >> 4);
    inst.ops[i].opinfo2 = ((int)buf[pos] & 0xF);
    inst.ops[i].optype = ((int)buf[pos + 1]) >> 4;
    inst.ops[i].oplen = ((int)buf[pos + 1] & 0x0F) + 1;
    pos += 2;

    // CASE REGISTER OPERAND
    if (!inst.ops[i].optype) {
      if (inst.ops[i].opinfo1 < 3) {
        inst.ops[i].op = buf[pos];
      } else {
        cout << "DECODING ERR\n";
        exit(0);
      }
      pos += inst.ops[i].oplen;
      // CASE IMMEDIATE
    } else if (inst.ops[i].optype == 1) {
      inst.ops[i].op = get_imm(buf, pos, inst.ops[i].oplen);
      pos += inst.ops[i].oplen;
      // CASE MEMORY OPERAND
    } else if (inst.ops[i].optype == 2) {
      do {
        memop_cfg = (int)buf[pos];
        memlen = (memop_cfg >> 4) & 0xFF;
        signconfig = memop_cfg & 8;

        if (!(memop_cfg & 7)) {
          if (!sec_reg) {
            inst.ops[i].op = (int)buf[pos + 1];
            inst.ops[i].reg_mod = -1;
          } else
            inst.ops[i].reg_mod = (int)buf[pos + 1];
          sec_reg = 1;
        }
        if ((memop_cfg & 7) == 1) {
          if (memlen == 1) {
            inst.ops[i].memoffs = (int)buf[pos + 1];
          } else if (memlen == 2) {
            inst.ops[i].memoffs = get_word_from_bytes(buf, pos + 1);
          } else if (memlen == 3) {
            inst.ops[i].memoffs = get_dword_from_bytes(buf, pos + 1);
          } else {
            inst.ops[i].memoffs = 0;
          }
        }
        pos += memlen;

      } while (((int)buf[pos]));
      pos++;
    } else {
      break;
    }
    i++;
  }
  return inst;
}

int main(int argc, char *argv[]) {
  char *buf;
  int i = 0;
  int iid, isize, iopcount;
  buf = (char *)malloc(0x2000);
  Instruction inst;
  cout << "[+] Disassembling 0x" << hex << CODE_SIZE << " bytes \n";
  if (argc < 2) {
    cout << "[!] No arguments entered, aborting.";
    exit(1);
  }
  if (!read_code(argv[1], buf, VM_START, VM_END - VM_START)) {
    cout << "[!] Error reading vm code from file\n";
    exit(0);
  }
  while (i <= (VM_END - VM_START)) {
    iid = (int)buf[i];                   // instruction id
    isize = ((int)buf[i + 1]) >> 2;      // instruction size
    iopcount = ((int)buf[i + 1]) & 0x3;  // number of operands
    if (!isize)  // if instruction size zero, quit, end reached
      break;
    inst = get_instruction(buf, i, isize);  // parse a single instruction
    inst.print_instruction(i);
    i += isize;
  }
  free(buf);
}
